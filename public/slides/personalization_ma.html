<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title> Pernicious Personalization?</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: top, center, title-slide

# <br>Pernicious Personalization?
## A Field Experiment using Automated Accounts on Twitter
### <br>Master thesis submitted in partial fulfillment of the requirements for the degree of Master of Arts (M. A.) in Empirical Political and Social Research<br><br>Fabio Votta<br><br>24 June 2020<br>Slides available here:<br><a href="http://www.favstats.eu/slides/personalization_ma">favstats.eu/slides/personalization_ma</a>

---





class: center, middle, inverse



&lt;style&gt;
.onehundredtwenty {
  font-size: 120%;
   }

&lt;style&gt;
.ninety {
  font-size: 90%;
   }
   
.eightyseven {
  font-size: 87%;
   }

.eightyfive {
  font-size: 85%;
   }
   
.eighty {
  font-size: 80%;
   }
   
.seventyfive {
  font-size: 75%;
   }
   
.seventy {
  font-size: 70%;
   }
   
.twentyfive {
  font-size: 25%;
   }
&lt;/style&gt;



## Relevance

---


## Relevance


![](images/filter_bubble.png)

---

## Relevance


![](images/knight.png)

---

## Goals

Three main contributions of this thesis:

1. Theoretically and analytically distinguish echo chamber from filter bubble effects.

2. Foxus on what the algorithm does before analyzing how algorithms influence people and societies.

3. Development and application of an **algorithm audit study** that can be used on other platforms and contexts.

---


class: center, middle, inverse


## Echo Chambers vs. Filter Bubbles

---

## Echo Chambers vs. Filter Bubbles


The main difference refers to the **authority in charge of selection**. 

--

&lt;!-- While in an echo chamber, users are mainly in charge of selecting the content they will be exposed to, in the case of filter bubbles, an individual does not directly control which content is selected and how the selection happens. In fact, as algorithms are the default on most prominent social media pages, users could be totally unaware of algorithmic selection. --&gt;

**Echo chamber mechanism**

A user chooses to read specific sources or follow users that reinforce the opinion that they already hold.


&amp;#x2192; Explicit Personalization (Thurman &amp; Schifferes 2012)

--

**Filter bubble mechanism**

A platform will track user behavior and curate their news feed accordingly.

&amp;#x2192; Implicit Personalization (Thurman &amp; Schifferes 2012)

---

## Research Questions

+ *RQ1:* Can we distinguish echo chamber from filter bubble effects?

--

+ *RQ2:* Does the algorithm infer political ideology from user data, and does that
lead to an ideologically homogeneous timeline over time?

--

+ *RQ3:* Are algorithmic timelines ideologically more homogeneous than nonalgorithmic ones?

--

+ *RQ4:* If the algorithm promotes homogeneity, does it affect conservative and
liberal content to the same extent?

--

+ *RQ5:* Does the algorithm “radicalize” users by showing them increasingly partisan
content?


---

## Twitter as a Use-Case

+ Twitter is one of the major social media platforms
   + *126 million* daily active users and a vivid space for political discussions (Twitter 2019c; TwitterGov 2016). 
   
--

+ Twitter algorithm that ranks content for the user by default. 
   + Users can deactivate the algorithmic timeline, but this is only opt-out by default. 
   
--

+ Good data access via Twitter API
   + Makes it possible to reconstruct the unfiltered version of the timeline.

---

## Actions

Four (algorithm-relevant) actions a user can take on Twitter

A user can

+ follow other accounts

+ retweet content

+ like content

+ leave comments

---

## Actions

Four (algorithm-relevant) actions a user can take on Twitter

A user can

+ follow other accounts

&amp;#x2192; Explicit personalization

--

+ retweet content, 

+ like content

+ leave comments

&amp;#x2192; Implicit personalization



---

## H1: Explicit personalization

Tailoring content by explicitly telling the algorithm what kind of content the user is interested in.


&gt; H1: The Twitter algorithm will display ideologically reinforcing and crosscutting content in the same proportion as the user explicitly tells it to.


---

## H2: Implicit vs. Explicit personalization

If a person engages with content on Twitter (by liking, retweeting and commenting) they reveal more information about their preferences. 

&gt; H2: Explicit personalization deprioritizes ideologically crosscutting content more so than implicit personalization. This will be true in terms of frequency (H2a) and ranking (H2b).

---

## H3 &amp; H4: Algorithmic vs. non-algorithmic timelines

If a person engages with content on Twitter they reveal more information about their preferences. In this case we would expect that engagement history will be used by the algorithm to show *more* similar content to the user to maximize engagement.

&gt; H3: Algorithmic timelines (explicit and implicit pesonalization) deprioritize crosscutting content more than non-filtered ones. This will be true in terms of frequency (H3a) and ranking (H3b).

&gt; H4: Implicitly personalized timelines deprioritize crosscutting content more than non-algorithmic timelines. This will be true in terms of frequency (H4a) and ranking (H4b).

---



## H5: "Radicalization" Hypothesis

Without built-in limitation, we would expect that the more an algorithm learns about the ideological leanings of their users the more partisan the content it displays will be.

&gt; H5: Implicitly pesonalized timelines are more ideologically partisan than explicit personalized (H5a) and non-algorithmic timelines (H5b).

---


class: center, middle, inverse


## Methods

Research Design and Measurement

---

## Research Design

&lt;center&gt;

&lt;img src="images/figure_3_full.png" width="550px" height="500px" /&gt;

&lt;/center&gt;

---

## Research Design

&lt;center&gt;

&lt;img src="images/figure_3_00.png" width="550px" height="500px" /&gt;

&lt;/center&gt;

---

## Research Design


&lt;center&gt;

&lt;img src="images/figure_3_01.png" width="550px" height="500px" /&gt;

&lt;/center&gt;

---

## Research Design


&lt;center&gt;

&lt;img src="images/figure_3_02.png" width="550px" height="500px" /&gt;

&lt;/center&gt;

---


## Research Design

&lt;center&gt;

&lt;img src="images/figure_3_03.png" width="550px" height="500px" /&gt;

&lt;/center&gt;


---

## Research Design

&lt;center&gt;

&lt;img src="images/figure_3_full.png" width="550px" height="500px" /&gt;

&lt;/center&gt;

---

&lt;!-- ## Research Design --&gt;

&lt;!-- **Chronological Timeline** --&gt;

&lt;!-- This condition will serve as a counterfactual for each bot as it simulates what a given user would have seen if no algorithmic filters are applied. --&gt;


&lt;!-- Instead, chronological timelines for each bot are constructed in the following way: first, all tweets created by the accounts that bots follow in their respective time they were active are collected via the Twitter API. This serves as the pool of tweets that each bot could have potentially seen. Each time a bot started a session, it also made a note of the exact time and date that it started. So for instance, if a bot session was initiated on 11 am on November 13th, 2019 and collected 124 tweets, the equivalent chronological timeline was constructed by considering the entire pool of tweets that the bot could have seen and filtering it only to include the 124 latest tweets after 11 am November 13th, 2019. This way, we can ensure that all chronological timelines are the exact same tweets that a user would have seen at that specific time if it were not for algorithmic sorting. --&gt;

&lt;!-- --- --&gt;

## Session Logic


&lt;img src="images/figure_8_full.png" width="2073" /&gt;

---

## Session Logic


&lt;img src="images/figure_8_01.png" width="2073" /&gt;

---

## Session Logic


&lt;img src="images/figure_8_02.png" width="2073" /&gt;

---


## Session Logic


&lt;img src="images/figure_8_03.png" width="2073" /&gt;

---

## Session Logic


&lt;img src="images/figure_8_full.png" width="2073" /&gt;


---

## Measurement of Ideology

The measure for political ideology needs to fulfill two purposes: 

1. provide info on who the bot should follow, and 

2. serve as the dependent variable for the hypotheses to be tested.

--

**Main Dependent Variables**

1. Percentage of Crosscutting Content 

2. Rank of Crosscutting Content

3. Ideology Score

---

## Inferring ideology from text with `deepvoter`

--

&lt;center&gt;

&lt;img src="images/gg_valid.png" width="550px" height="520px" /&gt;

&lt;/center&gt;


---

## Results

Data collection for the Twitter accounts went on for *33 days* 
  + 29th October to 30th November 2019 
  
Total of 438,694 tweets appeared in the timelines of 28 Bots
  + 138,860 (31.65%) were unique tweets

---

## DV: % Crosscutting Content 


&lt;img src="images/figure_10.png" width="1353" /&gt;

---

## DV: % Crosscutting Content 


&lt;img src="images/table_2.png" width="1123" /&gt;


---


## DV: % Crosscutting Content 

&lt;img src="images/figure_13.png" width="1385" /&gt;


---

## DV: Rank Crosscutting Content


&lt;img src="images/figure_11.png" width="1487" /&gt;


---


## DV: Rank Crosscutting Content


&lt;img src="images/figure_15.png" width="1508" /&gt;


---


## DV: Ideology Score


&lt;img src="images/figure_12.png" width="1439" /&gt;


---


## DV: Ideology Score


&lt;img src="images/figure_16.png" width="1385" /&gt;


---

## Conclusions

The study is very valid :D
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"slideNumberFormat": "%current%<br>"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
